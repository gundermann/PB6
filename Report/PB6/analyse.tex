\section{Analyse der Arbeitserleichterung}\label{Analyse derArbeitserleichterung}Im vorherigen Kapitel wurden folgende 4 Arbeitsschritte ausfindig gemacht, diemittels \emph{Xtext} direkt effizienter gestaltet werden können. \begin{enumerate}\item Prüfungskonfiguration definieren (siehe Kapitel \ref{TP2})\item Codereview (siehe Kapitel \ref{TP2})\item Fehlersuche (des Kunden, siehe Kapitel \ref{TP3})\item Fehlersuche (der deg, siehe Kapitel \ref{TP3})\end{enumerate}\subsection{Effizienzsteigerung mit \emph{Xtext} durch eine Grammatik}Für die folgende Analyse wird in Betracht gezogen, dass für die Sprache zurDefinition von Prüfungskonfigurationen eine Grammatik existiert, die von\emph{Xtext} verwendet werden kann. Diese Grammatik wurde im Praxisbericht\emph{Entwicklung einer Grammatik für eine DSL mit xText am Beispiel einerSprache zur Definition von Pflichtprüfungen in profil c/s}\simplevcite{pb5}entwickelt. Um alle Konfigurationsdateien bzgl. der Syntax zu validieren, warennoch einige Erweiterungen der Grammatik von Nöten (siehe \hyperref[an]{Anlage}).Beispielsweise mussten Kommentare in die Menge der Terminale aufgenommen werden.\begin{lstlisting}[caption = Kommentare mit '\#' als Terminale]terminal SL_COMMENT:	'#' !('\n' | '\r')* ('\r'? '\n')?;\end{lstlisting}Darüber hinaus wurden die Terminale zur Definition von \emph{Aktionen},\emph{Wirkungen} und \emph{Klassennamen} auf die in profil c/s verwendetenBezeichnungen eingeschränkt. Listing \ref{wirkungenrule} zeigt dies für die\emph{Wirkungen}. Die Umsetzung für die \emph{Aktionen} und \emph{Klassennamen}ist analog dazu in der \hyperref[an]{Anlage} zu finden.\begin{lstlisting}[caption = Terminale für Wirkungen, label = wirkungenrule]WIRKUNG:	'VERHINDERT_AKTION' | 'OHNE' | 'WARNUNG';\end{lstlisting}Erzeugt man mit \emph{Xtext} einen Editor, der die verwendete Syntax in denKonfigurationsdateien hinsichtlich dieser Grammatik überprüft, können dadurchfolgende Fehlerquellen ausgeschlossen werden.\begin{itemize}  \item Verwendung falscher Sprachkonstrukte  \item Zuweisung von Aktionen, die in profil c/s nicht existieren  \item Zuweisung von Wirkungen, die in profil c/s nicht existieren  \item Zuweisung von Klassennamen (Prüfungsalgorithmen), die in profil c/s  nicht existieren\end{itemize}Voraussetzung dafür ist jedoch, dass \emph{Aktionen}, \emph{Wirkungen} und\emph{Klassennamen} auch in der Grammatik gepflegt werden.\\Die Arbeit wäre durch die wegfallenden Fehlerquellen effizienter. Darüber hinausmuss der Entwickler auch nicht mehr nach dem qualifizierten Klassennamensuchen, weil ihn dieser vom Editor vorgeschlagen wird. Dies wäre auch bei derSuche nach den richtigen Bezeichnungen für die \emph{Aktionen} oder\emph{Wirkungen} von Vorteil.\\Beim Codereview muss bedacht werden, dass keine Semantikgeprüft wird. Besonders ist darauf zu achten, dass sämtliche IDs korrektdeklariert und zugewiesen sind.\\Bei der Fehlersuche kann somit ein syntaktischer Fehler ausgeschlossenwerden.\footnote{Sollte es dennoch zu einem Syntaxfehler kommen, muss dieGrammatik angepasst werden.} Die Mitarbeiter der deg können sich bei derFehlersuche auf die fachliche Korrektheit der Prüfungskonfiguration und auf diesemantischen Zusammenhänge konzentrieren. Der Kunde geniest bei der Fehlersuchedadurch derzeit keinen Vorteil. Wäre der Kunde jedoch in der Lage dieKonfigurationsdateien zu lesen und zu verstehen, könnte auch dieser diefachlichen Konzepte der Prüfungskonfiguration prüfen und sie mit dem Angebotabgleichen.\footnote{Neben einem Fehler in der Konfiguration kann auch ein vom Kunden nicht ausreichend geprüftes,aber angenommenes Angebot zu einem nichterwarteten Ergebnis des Tests führen.}\subsection{Effizienzsteigerung mit \emph{Xtext} durch Validierung}Mittels Validierungen können bei \emph{Xtext} semantische Zusammenhänge geprüftwerden. In dem Beispiel der Konfigurationsdateien sind im Folgenden 3 Askpektebeschrieben, die mit Hilfe der Grammatik nicht abgesichert werden können. \begin{enumerate}  \item Deklaration der IDs\\	In den Konfigurationsdateien werden die Prüfungen zu den Anträgen über	die Prüfungs-ID und die ID des Antrags bzw. das Schlüsselwort der	Antragsart zugewiesen.	Die Prüfungs-ID muss dazu im Vorfeld deklariert werden. \\	Andersherum sind auch Deklarationen von IDs unnötig, die keinem Antrag	zugewiesen werden.  \item Durchgängig laufende Nummer\\  	Die laufende Nummer, die bei der Zuweisung	mehrerer \emph{Wirkungen} und \emph{Aktionen} zur Prüfungskonfiguration benutzt	wird, muss bei eins beginnen, fortlaufend sein und darf	keine Zahl überspringen.\footnote{Genaueres dazu ist im Praxisbericht	\emph{Entwicklung einer Grammatik für eine DSL mit xText am Beispiel einer Sprache zur  	Definition von Pflichtprüfungen in profil c/s}\cite{pb5} zu finden.} 	Wird eine Nummer ausgelassen, werden die	Konfigurationen mit den nachfolgenden Nummern nicht berücksichtigt.  \item Einmalige Definition bestimmter Eigenschaften\\  Die Eigenschaften \emph{Kurzbezeichnung}, \emph{Langtext}  und \emph{Klassenname} einer Konfiguration dürfen nur einmal definiert werden.  Werden sie mehrfach definiert, wird die jeweilige Konfiguration  verwendet, die in der Datei am weitesten vorne steht.\end{enumerate}Um diese Aspekte abzusichern, sind Validierungen nötig, die im Zuge diesesBerichtes implementiert wurden. In den folgenden Kapiteln wird auf dieseImplementierung (siehe \hyperref[an]{Anlage}) eingegangen.\\Für sämtliche Validierungen bietet \emph{Xtext} eine Validatorklasse. DieMethoden dieser Klasse, die mit \emph{Check} annotiert sind, werden bei derValidierung ausgeführt. Entsprechende Warnungen oder Fehler, werden innerhalbdieser Methoden mit \emph{warning(String meldung, EStructuralFeature feature,int index)} oder \emph{error(String meldung, EStructuralFeature feature,int index)} implementiert. Die \emph{meldung} beinhaltet die Fehlermeldung oderWarnung, die dem Nutzer angezeigt wird. Die anderen Parameter\emph{feature} und \emph{index} bestimmen die Position der Warnung oder desFehlers im Eclipse-Editor. Das \emph{feature} beschreibt dabei die in derKonfigurationsdatei definierte Eigenschaft und der \emph{index} bestimmt umwelche Prüfung es sich handelt. Mit beiden Werten (Eigenschaft und Prüfung) kannder Editor die entsprechende Stelle in der Konfigurationsdatei genaulokalisieren.\subsubsection{Absicherung der ID-Deklaration}Bei der Absicherung der notwendigen Deklarationen von Prüfungs-ID wird mitfolgenden Code-Ausschnitt geprüft, ob die Prüfungs-IDs deklariert wurden, diebei der Zuweisung der Prüfungen zu Anträgen verwendet werden.\begin{lstlisting}[caption = Validierung der Deklaration von Prüfungs-IDs fürdie Zuweisung zu Anträgen]	@Check	def checkIdsFuerAntragszuweisungDeklariert(Konfiguration konfiguration) {		checkIdsVonZuweisungDeklariert(konfiguration.spezantragszuweisung, konfiguration.usedids.get(0),			DslPackage.Literals.KONFIGURATION__SPEZANTRAGSZUWEISUNG)	}		@Check	def checkIdsFuerAntragsArtzuweisungDeklariert(Konfiguration konfiguration) {		checkIdsVonZuweisungDeklariert(konfiguration.antragszuweisung, konfiguration.usedids.get(0),			DslPackage.Literals.KONFIGURATION__ANTRAGSZUWEISUNG)	}	def checkIdsVonZuweisungDeklariert(EList<String> konfigurationen, String konfigFuerDeklarierteIDs,		EStructuralFeature feature) {		var index = 0		for (konfiguration : konfigurationen) {			var zugewiesenePruefungen = extrahiereDeklariertePruefungen(konfiguration)			for (pruefung : zugewiesenePruefungen) {				var deklariertePruefungen = extrahiereDeklariertePruefungen(konfigFuerDeklarierteIDs)				if (!deklariertePruefungen.contains(pruefung.trim)) {					warning(String.format(WARNUNG_KEINE_ID_DEKLARIERT, pruefung), feature, index)				}			}			index++		}	}\end{lstlisting}\noindentWeiterhin muss geprüft werden, ob alle deklarierten IDs mindestens einem Antragzugeordnet sind. Das wird wie folgt umgesetzt.\begin{lstlisting}[caption = Validierung der Verwendung von deklariertenPrüfungs-IDs] 	@Check	def checkIdVerwendung(Konfiguration konfig) {		var deklariertePruefungen = extrahiereDeklariertePruefungen(konfig.usedids.get(0))		for (String pruefung : deklariertePruefungen) {			checkVerwendungInAntrag(konfig.antragszuweisung, konfig.spezantragszuweisung, pruefung)		}	}		def checkVerwendungInAntrag(EList<String> zuweisungenZuAntragsart, EList<String> zuweisungenZuAntrag,		String pruefung) {		for (antragsartZuweisung : zuweisungenZuAntragsart) {			var zugewiesenePreufungen = extrahiereDeklariertePruefungen(antragsartZuweisung)			if (zugewiesenePreufungen.contains(pruefung)) {				return			}		}		for (antragsZuweisung : zuweisungenZuAntrag) {			var zugewiesenePreufungen = extrahiereDeklariertePruefungen(antragsZuweisung)			if (zugewiesenePreufungen.contains(pruefung)) {				return			}		}		error(String.format(WARNUNG_PRUEFUNG_KEINEM_ANTRAG_ZUGEWIESEN, pruefung),			DslPackage.Literals.KONFIGURATION__USEDIDS)	}\end{lstlisting}Der entsprechende Fehler wird genau an der Stelle angezeigt, wo die nichtdeklarierte Prüfungs-ID verwendet wird bzw. wo die nicht verwendetePrü\-fungs-ID deklariert wird.\\Durch diese Validierung wird dem Entwickler das Prüfen der Vollständigkeit derdeklarierten Prüfung abgenommen. Außerdem wird zusätzlich überprüft, ob unnötigeDeklarationen stattgefunden haben.\subsubsection{Durchgängig laufende Nummer}\label{laufendeNr}Die laufende Nummer ist nur für zwei Eigenschaften einer Prüfungskonfigurationwichtig\footnote{\emph{Wirkung} und \emph{Aktion}}. Die Validierung wird wiefolgt umgestzt.\begin{lstlisting}[caption = Validierung der durchgängig laufenden Nummer]	@Check	def checkLaufendeNummerWirkung(Konfiguration konfiguration) {		checkFehltZahlInLaufenderNummer(			extrahierePruefungZuLaufendeNummerMapFuerEigenschaft(konfiguration.pruefungswirkung), "Wirkung",			DslPackage.Literals.KONFIGURATION__PRUEFUNGSWIRKUNG);	}		@Check	def checkLaufendeNummerAktion(Konfiguration konfiguration) {		checkFehltZahlInLaufenderNummer(			extrahierePruefungZuLaufendeNummerMapFuerEigenschaft(konfiguration.pruefungsaktion), "Aktion",			DslPackage.Literals.KONFIGURATION__PRUEFUNGSAKTION);	}		def checkFehltZahlInLaufenderNummer(HashMap<String, ArrayList<Integer>> map, String eigenschaft,		EStructuralFeature feature) {		var index = 0		for (pruefung : map.keySet) {			var nummern = map.get(pruefung)			for (var ln = 1; ln < nummern.size; ln++) {				if (!nummern.contains(ln)) {					error(String.format(WARNUNG_KEINE_LAUFENDE_NUMMER, eigenschaft, pruefung,					ln), feature, index) }				index++			}		}	}\end{lstlisting}Dadurch wird eine Fehleranalyse weitaus einfacher. Das Suchen von nichtvorhandenen laufenden Nummern wird umso komplizierter, je unübersichtlicher undgrößer die Datei wird.\\Abgesehen von der Vereinfachung der Fehleranalyse erspart diese Validierung auchbeim definieren von Prüfungskonfigurationen Arbeit, da der Editor überprüft, welche die nächstelaufende Nummer ist.\subsubsection{Einmalige Definition bestimmter Eigenschaften}Diese Prüfung verhindert Nebeneffekte, die entstehen, wenn eineEigenschaft in der Datei versehentlich doppelt definiertwird. Bei den Eigenschaften, die eine laufende Nummer benötigen, ist diesesProblem durch die zweite beschriebene Validierung (sieheKapitel\ref{laufendeNr}) abgesichert. Bei den anderen Eigenschaften wird dieswie folgt sicher gestellt.\begin{lstlisting}[caption = Validierung der einmaligen Definition]	@Check	def checkMehrfacheDefinition(Konfiguration konfig) {		var deklariertePruefungen = extrahiereDeklariertePruefungen(konfig.usedids.get(0))		for (String pruefung : deklariertePruefungen) {			checkMehrfacheVerwendungDerPruefung(konfig.pruefungskurzbezeichnung, pruefung,				DslPackage.Literals.KONFIGURATION__PRUEFUNGSKURZBEZEICHNUNG)			checkMehrfacheVerwendungDerPruefung(konfig.pruefungslangtext, pruefung,				DslPackage.Literals.KONFIGURATION__PRUEFUNGSLANGTEXT)			checkMehrfacheVerwendungDerPruefung(konfig.pruefungsichtbarkeit, pruefung,				DslPackage.Literals.KONFIGURATION__PRUEFUNGSICHTBARKEIT)		}	}		def checkMehrfacheVerwendungDerPruefung(EList<String> list, String pruefung,	EAttribute attribute) { var index = 0		var gefundeneKonfigurationen = 0		for (konfiguration : list) {			var pruefungBenutzt = extrahierePruefung(konfiguration)			if (pruefungBenutzt.equals(pruefung)) {				if (gefundeneKonfigurationen == 0)					gefundeneKonfigurationen = 1				else					error(String.format(WARUNUNG_DOPPELT_GENUTZTE_PRUEFUNG, attribute.name,					pruefung), attribute, index)			}			index++		}	}\end{lstlisting}Durch die Validierungsregeln können weitere Fehler ausgeschlossen werden, diesich auf die Semantik der Sprache zur Definition von Prüfungskonfigurationenbeziehen. Beim Definieren der Prüfungskonfigurationen hat das einen klarenVorteil. Die oben beschriebenen Validierungen werden vom Editor ausgeführtund müssen nicht vom Entwickler überprüft werden.\\Beim Codereview kann der Fokus hauptsächlich auf die fachlich korrekteDefinition der Eigenschaften gelegt werden\footnote{Bspw. ob dieKurzbezeichnung korrekt ist, oder alle nötigen Aktionen definiert wurden}.\\Für die Fehleranalyse gilt dasselbe. Auch hier kann man sich weitgehend auf diefachlichen Aspekte einer Prüfungskonfiguration konzentrieren. \\Das unterstützt auch den Kunden. Dieser kann selbst die Überprüfung derKonfigurationsdatei vornehmen, weil syntaktische Fehler und semantische Fehler,die nichts mit den fachlichen Festlegungen zu einer Prüfungskonfiguration(Festlegungen aus dem Angebot) zu tun haben, auszuschließen sind.